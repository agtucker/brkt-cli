#!/usr/bin/env python
"""
Create a bracket solo metavisor/guest AMI
complete with a encrypted root volume for a given guest AMI

Basic outline:
    create a guest AMI with the right permissions on root vol snapshot
    launch a metavisor AMI with
        *) unencrypted guest root volume as /dev/sda4
        *) (raw) guest root volume (2x size) as /dev/sda5
    wait for the metavisor to launch
        *) dd from /dev/sda4 to /dev/sda5 creating encrypted root for guest
    stop metavisor
    create new AMI from metavisor instance
        *) include ephemeral drives

At that point a new AMI contains the metavisor + encrypted guest root volume.
We should be able to auto-chain load the guest once this AMI is launched

Environment setup:
Either setup environment variables for:
export AWS_ACCESS_KEY_ID=XXXXXXX
export AWS_SECRET_KEY=XXXXXXX

or

export BOTO_CONFIG ~/.ec2/boto_config
------------
boto_config
------------
[Credentials]
aws_access_key_id = XXXXXXXXXXXXX
aws_secret_access_key = XXXXXXXXXXXX
------------
"""
import argparse
import boto
import boto.ec2
import boto.vpc
import logging
import sys
import time
import string
import re
import subprocess
import uuid

from datetime import datetime
from boto.exception import EC2ResponseError, BotoServerError
from boto.ec2.blockdevicemapping import (BlockDeviceMapping,
        BlockDeviceType, EBSBlockDeviceType)

sshflags = " ".join([
    "-o UserKnownHostsFile=/dev/null",
    "-o LogLevel=quiet",
    "-o StrictHostKeyChecking=no",
    "-o ConnectTimeout=5",
])

TAG_ENCRYPTOR = 'BrktEncryptor'
TAG_ENCRYPTOR_SESSION_ID = 'BrktEncryptorSessionID'

# Instance names.
NAME_SNAPSHOT_CREATOR = 'Bracket root snapshot creator'
NAME_ENCRYPTOR = 'Bracket image encryptor'

# Snapshot names.
NAME_ORIGINAL_SNAPSHOT = 'Bracket encryptor original volume'
NAME_ENCRYPTED_ROOT_SNAPSHOT = 'Bracket encrypted root volume'
NAME_METAVISOR_ROOT_SNAPSHOT = 'Bracket system root'
NAME_METAVISOR_GRUB_SNAPSHOT = 'Bracket system GRUB'
NAME_METAVISOR_LOG_SNAPSHOT = 'Bracket system log'
NAME_ENCRYPTED_AMI = 'Bracket encrypted AMI'

log = None


class EncryptorSession(object):
    __slots__ = [
        'conn',           # Boto AWS connection
        'session_id',     # Unique ID for this AMI encryption session
        'guest_ami',      # The ID of the original unencrypted guest AMI
        'encryptor_ami',  # The Bracket Encryptor AMI ID
    ]

session_id = None


def ssh(user, external_ip, sshcommand, background=False):
    if background:
        extra_flags = " -f"
    else:
        extra_flags = ""
    command = 'ssh %s%s %s@%s "%s"' % (sshflags, extra_flags, user,
                                       external_ip, sshcommand)
    log.debug(command)
    if background:
        return subprocess.check_call(command, shell=True)
    else:
        return subprocess.check_output(command, shell=True)


def safe_ssh(*args, **kwargs):
    for _ in range(20):
        try:
            return ssh(*args, **kwargs)
        except subprocess.CalledProcessError as e:
            time.sleep(1)
    else:
        raise e


def aws_call(tries, sleep, func, *args, **kwargs):
    try:
        return func(*args, **kwargs)
    except (EC2ResponseError, BotoServerError):
        if tries <= 1:
            raise
        time.sleep(sleep)
        return aws_call(tries - 1, sleep, func, *args, **kwargs)


def create_snapshot(conn, vol_id, desc):
    # TODO: Is this required? Can't we use vol_id?
    vol = conn.get_all_volumes(volume_ids=[vol_id])[0]
    snap = conn.create_snapshot(vol.id, desc)
    return snap


def copy_vol_snapshot(conn, vol_id, desc):
    # TODO: Is this required? Can't we use vol_id?
    vol = conn.get_all_volumes(volume_ids=[vol_id])[0]
    region = vol.zone[:-1]
    snap_id = conn.copy_snapshot(region, vol.snapshot_id, desc)
    snap = conn.get_all_snapshots([snap_id])[0]
    return snap


def wait_for_status(status, *snaps):
    while not all(map(lambda s: s.status == status, snaps)):
        time.sleep(10)
        sys.stderr.write('.')
        sys.stderr.flush()
        for snap in snaps:
            snap.update()
    sys.stderr.write('\n')


def wait_for_instance(conn, instance_id, timeout=60, state='running'):
    """ Wait for up to timeout seconds for an instance to be in the
        'running' state.  Sleep for 2 seconds between checks.
    :return: The Instance object, or None if a timeout occurred
    """

    start_timestamp = datetime.utcnow()
    now = start_timestamp

    log.debug(
        'Waiting for %s, timeout=%d, state=%s',
        instance_id, timeout, state)
    while (now - start_timestamp).total_seconds() < timeout:
        instance = conn.get_only_instances(instance_ids=[instance_id])[0]
        log.debug('Instance %s state=%s', instance.id, instance.state)
        if instance.state == state:
            return instance
        time.sleep(2)
    return None


def create_tags(conn, resource_id, name=None):
    tags = {
        TAG_ENCRYPTOR: True,
        TAG_ENCRYPTOR_SESSION_ID: session_id
    }
    if name:
        tags['Name'] = name
    log.debug('Tagging %s with %s', resource_id, tags)
    conn.create_tags([resource_id], tags)


def run_copy_instance(conn, ami, zone, key_name,
                      inst_type, snapshot, root_size, userdata):
    log.info('Launching encryptor instance with snapshot %s', snapshot)

    # Use gp2 for fast burst I/O copying root drive
    guest_unencrypted_root = EBSBlockDeviceType(
        volume_type='gp2',
        snapshot_id=snapshot,
        delete_on_termination=True)
    bdm = BlockDeviceMapping()
    bdm['/dev/sda4'] = guest_unencrypted_root

    # Use gp2 for fast burst I/O
    guest_encrypted_root = EBSBlockDeviceType(
        volume_type='gp2',
        delete_on_termination=True)

    guest_encrypted_root.size = 2 * root_size + 1
    bdm['/dev/sda5'] = guest_encrypted_root

    reservation = aws_call(20, 1, conn.run_instances, ami,
                           key_name=key_name,
                           instance_type=inst_type,
                           placement=zone,
                           ebs_optimized=False,
                           block_device_map=bdm,
                           user_data=userdata
                           )
    instance = reservation.instances[0]
    create_tags(conn, instance.id, name='Bracket volume encryptor')
    instance = wait_for_instance(conn, instance.id)
    log.info('Launched encryptor instance %s', instance.id)
    return instance


def wait_for_host_up(user, external_ip):
    st = time.time()
    time.sleep(60)
    for i in range(60):
        try:
            ssh(user, external_ip, 'ls')
            break
        except subprocess.CalledProcessError:
            time.sleep(10)
    else:
        raise Exception('Unable to contact %s' % (external_ip))
    et = time.time()
    log.debug('Host is ssh-able now after %.1f seconds', (et - st))


def terminate_instance(conn, instance):
    log.debug('Terminating instance %s', instance.id)
    aws_call(20, 1, conn.terminate_instances, [instance.id])
    # need to wait for instance to die before tearing down rest
    while instance.state != 'terminated':
        time.sleep(5)
        instance.update()


def create_root_snapshot(conn, ami, key):
    # Launch the snapshotter instance.
    res = conn.run_instances(
        image_id=ami,
        key_name=key,
        instance_type='m3.medium'
    )
    instance = res.instances[0]
    create_tags(conn, instance.id, NAME_SNAPSHOT_CREATOR)
    log.info(
        'Launching instance %s to snapshot root disk for %s',
        instance.id, ami)
    instance = wait_for_instance(conn, instance.id)

    log.info(
        'Stopping instance %s in order to create snapshot', instance.id)
    instance.stop()
    wait_for_instance(conn, instance.id, state='stopped')

    # Snapshot root volume.
    root_dev = conn.get_instance_attribute(
        instance_id=instance.id, attribute='rootDeviceName')['rootDeviceName']
    bdm = conn.get_instance_attribute(
        instance_id=instance.id, attribute='blockDeviceMapping')[
        'blockDeviceMapping']
    if root_dev not in bdm:
        # try stripping partition id
        root_dev = string.rstrip(root_dev, string.digits)
    root_vol = bdm[root_dev]
    vol = conn.get_all_volumes(volume_ids=[root_vol.volume_id])[0]
    snapshot = conn.create_snapshot(
        vol.id,
        'Original unencrypted root volume from ' + ami
    )
    log.info(
        'Creating snapshot %s of root volume for instance %s',
        snapshot.id, instance.id
    )
    create_tags(
        conn, snapshot.id, name=NAME_ORIGINAL_SNAPSHOT)
    while snapshot.status != 'completed':
        time.sleep(5)
        snapshot.update()

    # Terminate snapshotter instance.
    log.info(
        'Created snapshot %s.  Terminating instance %s',
        snapshot.id, instance.id
    )
    instance.terminate()
    # wait for instance to free up root volume before deleting it
    try:
        while vol.status != 'available':
            log.debug('Volume %s, status=%s', vol.id, vol.status)
            time.sleep(5)
            vol.update()
            conn.delete_volume(root_vol.volume_id)
    except EC2ResponseError:
        # volume might have been auto-deleted when instance terminated
        pass

    retvals = (
        snapshot.id, root_dev, vol.size, root_vol.volume_type, root_vol.iops)
    log.debug('Returning %s', str(retvals))
    return retvals


def wait_for_image(conn, image_id):
    log.debug('Waiting for %s to become available.', image_id)
    for i in range(180):
        time.sleep(5)
        try:
            image = conn.get_all_images([image_id])[0]
        except EC2ResponseError, e:
            if e.error_code == 'InvalidAMIID.NotFound':
                log.debug('AWS threw a NotFound, ignoring')
                continue
            else:
                log.warn('Unknown AWS error: %s', str(e))
        # These two attributes are optional in the response and only
        # show up sometimes. So we have to getattr them.
        reason = repr(getattr(image, 'stateReason', None))
        code = repr(getattr(image, 'code', None))
        log.debug("%s: %s reason: %s code: %s",
                      image.id, image.state, reason, code)
        if image.state == 'available':
            break
        if image.state == 'failed':
            raise Exception('Image state became failed')
    else:
        raise Exception(
            'Image failed to become available (%s)' % (image.state,))


def validate_guest_ami(conn, ami_id):
    try:
        images = conn.get_all_images([ami_id])
    except EC2ResponseError, e:
        return e.error_message
    if len(images) == 0:
        return '%s is no longer available' % ami_id
    image = images[0]
    if image.root_device_type != 'ebs':
        return '%s does not use EBS storage.' % ami_id
    if image.hypervisor != 'xen':
        return '%s uses Hypervisor %s.  Only xen is supported' % (
            ami_id, image.hypervisor)
    return None


def validate_avatar_ami(conn, ami_id):
    try:
        images = conn.get_all_images([ami_id])
    except EC2ResponseError, e:
        return e.error_message
    if len(images) == 0:
        return 'Bracket encryptor image %s is no longer available' % ami_id
    image = images[0]
    if not 'brkt-avatar' in image.name:
        return '%s (%s) is not a Bracket Encryptor image' % (
            ami_id, image.name)
    return None


def main(argv):
    global sshflags

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-v',
        '--verbose',
        dest='verbose',
        action='store_true',
        help='Print status information to the console'
    )

    subparsers = parser.add_subparsers()

    encrypt_ami = subparsers.add_parser('encrypt-ami')
    encrypt_ami.add_argument(
        'ami',
        metavar='AMI_ID',
        help='The AMI that will be encrypted'
    )
    # Require the caller to specify the Avatar AMI ID until NUC-9085 is fixed.
    encrypt_ami.add_argument(
        '--encryptor-ami',
        metavar='ID',
        dest='avatar_ami',
        help='Bracket Encryptor AMI',
        required=True
    )
    encrypt_ami.add_argument(
        '--key',
        metavar='NAME',
        help='EC2 SSH Key Pair name',
        dest='key_name',
        required=True
    )
    encrypt_ami.add_argument(
        '--validate-ami',
        dest='no_validate_ami',
        action='store_true',
        help="Validate AMI properties (default)"
    )
    encrypt_ami.add_argument(
        '--no-validate-ami',
        dest='no_validate_ami',
        action='store_false',
        help="Don't validate AMI properties"
    )
    encrypt_ami.add_argument(
        '-z',
        '--availability-zone',
        metavar='NAME',
        help='AWS availability zone (e.g. us-west-2a)',
        dest='zone',
        required=True
    )

    values = parser.parse_args(argv)
    region = values.zone[:-1]

    # Initialize logging.  Log messages are written to stderr and are
    # prefixed with a compact timestamp, so that the user knows how long
    # each operation took.
    if values.verbose:
        log_level = logging.DEBUG
    else:
        log_level = logging.INFO
    logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%H:%M:%S')
    global log
    log = logging.getLogger(__name__)
    log.setLevel(log_level)

    global session_id
    session_id = uuid.uuid4().hex

    # Open up a persistent connection
    conn = boto.vpc.connect_to_region(region)

    if not values.no_validate_ami:
        error = validate_guest_ami(conn, values.ami)
        if error:
            log.error(error)
            exit(1)

        error = validate_avatar_ami(conn, values.avatar_ami)
        if error:
            log.error(error)
            exit(1)

    log.info('Starting encryptor session %s', session_id)

    # Create a snapshot of the guest root volume.
    snapshot_id = None
    (snapshot_id, root_dev, size, vol_type, iops) = \
        create_root_snapshot(conn, values.ami, values.key_name)
    log.debug(
        'snapshot=%s, root_dev=%s, size=%s, vol_type=%s, iops=%s',
        snapshot_id, root_dev, size, vol_type, iops)

    copy_instance = None
    exit_status = 0
    ami = None

    try:
        copy_instance = run_copy_instance(
            conn, values.avatar_ami, values.zone, values.key_name,
            "m3.medium", snapshot_id, size, None)

        host_ip = copy_instance.ip_address
        log.info('Waiting for ssh to %s at %s', copy_instance.id, host_ip)
        wait_for_host_up('avatar', host_ip)

        # Now Wait for the guest root to be created
        # Currently copying at around ~15 MB/sec
        log.info('Creating encrypted root drive.')
        while True:
            try:
                out = safe_ssh('avatar', host_ip,
                               "cat /etc/brkt/seed.yaml")
                if re.search('avatar_solo_created: true', out):
                    sys.stderr.write('\n')
                    log.info('Encrypted root drive created.')
                    break
                sys.stderr.write('.')
                sys.stderr.flush()
                time.sleep(10)
            except Exception:
                # TODO: Need to handle exception more gracefully
                log.exception('Waiting for guest install')
                time.sleep(10)

        bdm = aws_call(20, 1, conn.get_instance_attribute,
                       instance_id=copy_instance.id,
                       attribute='blockDeviceMapping')['blockDeviceMapping']

        # Create clean snapshots
        log.info('Stopping encryptor instance %s', copy_instance.id)
        copy_instance.stop()
        wait_for_instance(conn, copy_instance.id, state='stopped')

        description = 'Based on ' + values.ami
        snap_guest = create_snapshot(
            conn, bdm['/dev/sda5'].volume_id, description)
        create_tags(conn, snap_guest.id, name=NAME_ENCRYPTED_ROOT_SNAPSHOT)

        snap_bsd = create_snapshot(
            conn, bdm['/dev/sda2'].volume_id, description)
        create_tags(conn, snap_bsd.id, name=NAME_METAVISOR_ROOT_SNAPSHOT)

        snap_grub = copy_vol_snapshot(
            conn, bdm['/dev/sda1'].volume_id, description)
        create_tags(conn, snap_grub.id, name=NAME_METAVISOR_GRUB_SNAPSHOT)

        snap_log = copy_vol_snapshot(
            conn, bdm['/dev/sda3'].volume_id, description)
        create_tags(conn, snap_log.id, name=NAME_METAVISOR_LOG_SNAPSHOT)

        log.info(
            'Creating snapshots for the new encrypted AMI: %s, %s, %s, %s',
            snap_guest.id, snap_bsd.id, snap_grub.id, snap_log.id)

        wait_for_status('completed', snap_guest, snap_bsd, snap_grub, snap_log)

        # Set up new Block Device Mappings
        log.debug('Creating block device mapping')
        new_bdm = BlockDeviceMapping()
        dev_grub = EBSBlockDeviceType(volume_type='gp2',
                                      snapshot_id=snap_grub.id,
                                      delete_on_termination=True)
        dev_root = EBSBlockDeviceType(volume_type='gp2',
                                      snapshot_id=snap_bsd.id,
                                      delete_on_termination=True)
        dev_log = EBSBlockDeviceType(volume_type='gp2',
                                     snapshot_id=snap_log.id,
                                     delete_on_termination=True)
        if vol_type == '':
            vol_type = 'standard'
        dev_guest_root = EBSBlockDeviceType(volume_type=vol_type,
                                            snapshot_id=snap_guest.id,
                                            iops=iops,
                                            delete_on_termination=True)
        new_bdm['/dev/sda1'] = dev_grub
        new_bdm['/dev/sda2'] = dev_root
        new_bdm['/dev/sda3'] = dev_log
        new_bdm['/dev/sda5'] = dev_guest_root

        i = 0
        # Just attach 4 ephemeral drives
        # XXX Should get ephemeral drives from guest AMI (e.g. Centos 6.6)
        for drive in ['/dev/sdb', '/dev/sdc', '/dev/sdd', '/dev/sde']:
            t = BlockDeviceType()
            t.ephemeral_name = 'ephemeral%d' % (i,)
            i = i + 1
            new_bdm[drive] = t

        log.debug('Getting image %s', values.ami)
        image = aws_call(20, 1, conn.get_image, values.ami)
        if image is None:
            raise Exception("Can't find image %s" % (values.ami,))
        avatar_image = aws_call(20, 1, conn.get_image, values.avatar_ami)
        if avatar_image is None:
            raise Exception("Can't find image %s" % (values.avatar_ami,))

        name = 'Bracket_%s_%d' % (image.name, time.time())
        if image.description:
            description = 'Bracket: ' + image.description
        else:
            description = name

        try:
            log.debug('Registering image.')
            ami = conn.register_image(
                name=name, description=description,
                architecture='x86_64',
                kernel_id=avatar_image.kernel_id,
                root_device_name='/dev/sda1',
                block_device_map=new_bdm,
                virtualization_type='paravirtual')
            name = '%s based on %s' % (NAME_ENCRYPTED_AMI, values.ami)
            log.info('Registered AMI %s based on the snapshots.', ami)
            create_tags(conn, ami, name)
        except EC2ResponseError, e:
            # Sometimes register_image fails with an InvalidAMIID.NotFound
            # error and a message like "The image id '[ami-f9fcf3c9]' does not
            # exist".  In that case, just go ahead with that AMI id. We'll
            # wait for it to be created later (in wait_for_image).
            log.info(
                'Attempting to recover from image registration error: %s', e)
            if e.error_code == 'InvalidAMIID.NotFound':
                # pull the AMI ID out of the exception message if we can
                m = re.search('ami-[a-f0-9]{8}', e.message)
                if m:
                    ami = m.group(0)
                    log.info('Recovered with AMI ID %s', ami)
            if not ami:
                raise

        wait_for_image(conn, ami)
        log.info('Created encrypted AMI %s based on %s', ami, values.ami)
    except Exception:
        # TODO: Better exception handling
        log.exception('Aborting')
        exit_status = 1

    if copy_instance:
        log.info('Terminating encryptor instance %s', copy_instance.id)
        terminate_instance(conn, copy_instance)

    if snapshot_id:
        log.info('Deleting snapshot copy of original root volume %s',
                 snapshot_id)
        conn.delete_snapshot(snapshot_id)

    log.info('Done.')
    if ami:
        # Print the AMI ID to stdout, in case the caller wants to process
        # the output.  Log messages go to stderr.
        print ami

    sys.exit(exit_status)


if __name__ == '__main__':
    main(sys.argv[1:])
