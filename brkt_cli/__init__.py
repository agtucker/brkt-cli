# Copyright 2015 Bracket Computing, Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License").
# You may not use this file except in compliance with the License.
# A copy of the License is located at
#
# https://github.com/brkt/brkt-sdk-java/blob/master/LICENSE
#
# or in the "license" file accompanying this file. This file is
# distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR
# CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and
# limitations under the License.

from __future__ import print_function

import argparse
import boto
import boto.ec2
import boto.vpc
import logging
import re
import sys

from boto.exception import EC2ResponseError, NoAuthHandlerFound

from brkt_cli import aws_service
from brkt_cli import encrypt_ami
from brkt_cli import encrypt_ami_args
from brkt_cli import update_encrypted_ami_args
from brkt_cli import encryptor_service
from brkt_cli import util

from update_ami import update_ami

VERSION = '0.9.9pre1'

log = None


def _validate_subnet_and_security_groups(aws_svc,
                                         subnet_id=None,
                                         security_group_ids=None):
    """ Verify that the given subnet and security groups all exist and are
    in the same subnet.

    :return True if all of the ids are valid and in the same VPC
    :raise EC2ResponseError if any of the ids are invalid
    """
    vpc_ids = set()
    if subnet_id:
        # Validate the subnet.
        subnet = aws_svc.get_subnet(subnet_id)
        vpc_ids.add(subnet.vpc_id)

    if security_group_ids:
        # Validate the security groups.
        for id in security_group_ids:
            sg = aws_svc.get_security_group(id, retry=False)
            vpc_ids.add(sg.vpc_id)

    return len(vpc_ids) <= 1


class ValidationError(Exception):
    pass


def _connect_and_validate(aws_svc, values, encryptor_ami_id):
    """ Connect to the AWS service and validate command-line options

    :param aws_svc: the BaseAWSService implementation
    :param values: object that was generated by argparse
    """
    if values.encrypted_ami_name:
        try:
            aws_service.validate_image_name(values.encrypted_ami_name)
        except aws_service.ImageNameError as e:
            raise ValidationError(e.message)

    regions = [str(r.name) for r in aws_svc.get_regions()]
    if values.region not in regions:
        raise ValidationError(
            'Invalid region %s.  Must be one of %s.' %
            (values.region, str(regions)))

    aws_svc.connect(values.region, key_name=values.key_name)

    try:
        if values.key_name:
            aws_svc.get_key_pair(values.key_name)

        if not _validate_subnet_and_security_groups(
                aws_svc, values.subnet_id, values.security_group_ids):
            raise ValidationError(
                    'Subnet and security groups must be in the same VPC')

        if not values.no_validate_ami:
            error_msg = aws_svc.validate_guest_ami(values.ami)
            if error_msg:
                raise ValidationError(error_msg)

            error_msg = aws_svc.validate_encryptor_ami(encryptor_ami_id)
            if error_msg:
                raise ValidationError(error_msg)

        if values.encrypted_ami_name:
            filters = {'name': values.encrypted_ami_name}
            if aws_svc.get_images(filters=filters):
                raise ValidationError(
                        'There is already an image named %s' %
                        values.encrypted_ami_name
                )
    except EC2ResponseError as e:
        raise ValidationError(e.message)


def command_encrypt_ami(values, log):
    region = values.region

    encryptor_ami = values.encryptor_ami
    if not encryptor_ami:
        try:
            encryptor_ami = encrypt_ami.get_encryptor_ami(region)
        except:
            log.exception('Failed to get encryptor AMI.')
            return 1

    session_id = util.make_nonce()
    default_tags = encrypt_ami.get_default_tags(session_id, encryptor_ami)

    aws_svc = aws_service.AWSService(
        session_id, default_tags=default_tags)
    _connect_and_validate(aws_svc, values, encryptor_ami)

    log.info('Starting encryptor session %s', aws_svc.session_id)

    encrypted_image_id = encrypt_ami.encrypt(
        aws_svc=aws_svc,
        enc_svc_cls=encryptor_service.EncryptorService,
        image_id=values.ami,
        encryptor_ami=encryptor_ami,
        encrypted_ami_name=values.encrypted_ami_name,
        subnet_id=values.subnet_id,
        security_group_ids=values.security_group_ids,
        brkt_env=values.brkt_env
    )
    # Print the AMI ID to stdout, in case the caller wants to process
    # the output.  Log messages go to stderr.
    print(encrypted_image_id)
    return 0


def command_update_encrypted_ami(values, log):
    nonce = util.make_nonce()
    default_tags = encrypt_ami.get_default_tags(nonce, '')
    aws_svc = aws_service.AWSService(
        nonce, default_tags=default_tags)
    _connect_and_validate(aws_svc, values, values.updater_ami)

    encrypted_ami = values.ami
    if not values.no_validate_ami:
        guest_ami_error = aws_svc.validate_guest_encrypted_ami(encrypted_ami)
        if guest_ami_error:
            raise ValidationError(
                'Encrypted AMI verification failed: %s' % guest_ami_error)
    else:
        log.info('skipping AMI verification')
    updater_ami = values.updater_ami
    updater_ami_error = aws_svc.validate_encryptor_ami(values.updater_ami)
    if updater_ami_error:
        log.error('Update failed: %s', updater_ami_error)
        return 1
    guest_image = aws_svc.get_image(encrypted_ami)
    mv_image = aws_svc.get_image(updater_ami)
    if (guest_image.virtualization_type !=
        mv_image.virtualization_type):
        log.error("Encryptor virtualization_type mismatch")
        return 1
    encrypted_ami_name = values.encrypted_ami_name
    if not encrypted_ami_name:
        # Replace nonce in AMI name
        name = guest_image.name
        m = re.match('(.+) \(encrypted (\S+)\)', name)
        if m:
            encrypted_ami_name = m.group(1) + ' (encrypted %s)' % (nonce,)
        else:
            encrypted_ami_name = name + ' (encrypted %s)' % (nonce,)
        filters = {'name': encrypted_ami_name}
        if aws_svc.get_images(filters=filters):
            raise ValidationError(
                    'There is already an image named %s' %
                     encrypted_ami_name
            )
    # Initial validation done
    log.info('Updating %s with new metavisor %s', encrypted_ami, updater_ami)

    updated_ami_id = update_ami(
        aws_svc, encrypted_ami, updater_ami, encrypted_ami_name,
        subnet_id=values.subnet_id,
        security_group_ids=values.security_group_ids)
    print(updated_ami_id)
    return 0


def main():
    # Check Python version.
    version = '%d.%d' % (sys.version_info.major, sys.version_info.minor)
    if version != '2.7':
        print(
            'brkt-cli requires Python 2.7.  Version',
            version,
            'is not supported.',
            file=sys.stderr
        )
        return 1

    parser = argparse.ArgumentParser()
    parser.add_argument(
        '-v',
        '--verbose',
        dest='verbose',
        action='store_true',
        help='Print status information to the console'
    )
    parser.add_argument(
        '--version',
        action='version',
        version='brkt-cli version %s' % VERSION
    )

    subparsers = parser.add_subparsers(dest='subparser_name')

    encrypt_ami_parser = subparsers.add_parser('encrypt-ami')
    encrypt_ami_args.setup_encrypt_ami_args(encrypt_ami_parser)

    update_encrypted_ami_parser = \
        subparsers.add_parser('update-encrypted-ami')
    update_encrypted_ami_args.setup_update_encrypted_ami(
        update_encrypted_ami_parser)

    argv = sys.argv[1:]
    values = parser.parse_args(argv)
    # Initialize logging.  Log messages are written to stderr and are
    # prefixed with a compact timestamp, so that the user knows how long
    # each operation took.
    if values.verbose:
        log_level = logging.DEBUG
    else:
        # Boto logs auth errors and 401s at ERROR level by default.
        boto.log.setLevel(logging.FATAL)
        log_level = logging.INFO
    # Set the log level of our modules explicitly.  We can't set the
    # default log level to INFO because we would see INFO messages from
    # boto and other 3rd party libraries in the command output.
    logging.basicConfig(format='%(asctime)s %(message)s', datefmt='%H:%M:%S')
    global log
    log = logging.getLogger(__name__)
    log.setLevel(log_level)
    aws_service.log.setLevel(log_level)
    encryptor_service.log.setLevel(log_level)

    try:
        if values.subparser_name == 'encrypt-ami':
            return command_encrypt_ami(values, log)
        if values.subparser_name == 'update-encrypted-ami':
            return command_update_encrypted_ami(values, log)
    except ValidationError as e:
        print(e, file=sys.stderr)
    except NoAuthHandlerFound:
        msg = (
            'Unable to connect to AWS.  Are your AWS_ACCESS_KEY_ID and '
            'AWS_SECRET_ACCESS_KEY environment variables set?'
        )
        if values.verbose:
            log.exception(msg)
        else:
            log.error(msg)
    except EC2ResponseError as e:
        if e.error_code == 'AuthFailure':
            msg = 'Check your AWS login credentials and permissions'
            if values.verbose:
                log.exception(msg)
            else:
                log.error(msg + ': ' + e.error_message)
        elif e.error_code in (
                'InvalidKeyPair.NotFound',
                'InvalidSubnetID.NotFound',
                'InvalidGroup.NotFound'):
            if values.verbose:
                log.exception(e.error_message)
            else:
                log.error(e.error_message)
        elif e.error_code == 'UnauthorizedOperation':
            if values.verbose:
                log.exception(e.error_message)
            else:
                log.error(e.error_message)
            log.error(
                'Unauthorized operation.  Check the IAM policy for your '
                'AWS account.'
            )
        else:
            raise
    except util.BracketError as e:
        if values.verbose:
            log.exception(e.message)
        else:
            log.error(e.message)
    except KeyboardInterrupt:
        if values.verbose:
            log.exception('Interrupted by user')
        else:
            log.error('Interrupted by user')
    return 1


if __name__ == '__main__':
    exit_status = main()
    exit(exit_status)
